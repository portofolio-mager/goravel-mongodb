// Code generated by mockery. DO NOT EDIT.

package contracts

import (
	mock "github.com/stretchr/testify/mock"
	contracts "github.com/tonidy/goravel-mongodb/contracts"

	mongo "go.mongodb.org/mongo-driver/mongo"
)

// Collection is an autogenerated mock type for the Collection type
type Collection struct {
	mock.Mock
}

type Collection_Expecter struct {
	mock *mock.Mock
}

func (_m *Collection) EXPECT() *Collection_Expecter {
	return &Collection_Expecter{mock: &_m.Mock}
}

// CountDocuments provides a mock function with given fields: filter, opts
func (_m *Collection) CountDocuments(filter interface{}, opts ...interface{}) (int64, error) {
	var _ca []interface{}
	_ca = append(_ca, filter)
	_ca = append(_ca, opts...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CountDocuments")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) (int64, error)); ok {
		return rf(filter, opts...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) int64); ok {
		r0 = rf(filter, opts...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...interface{}) error); ok {
		r1 = rf(filter, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Collection_CountDocuments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountDocuments'
type Collection_CountDocuments_Call struct {
	*mock.Call
}

// CountDocuments is a helper method to define mock.On call
//   - filter interface{}
//   - opts ...interface{}
func (_e *Collection_Expecter) CountDocuments(filter interface{}, opts ...interface{}) *Collection_CountDocuments_Call {
	return &Collection_CountDocuments_Call{Call: _e.mock.On("CountDocuments",
		append([]interface{}{filter}, opts...)...)}
}

func (_c *Collection_CountDocuments_Call) Run(run func(filter interface{}, opts ...interface{})) *Collection_CountDocuments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Collection_CountDocuments_Call) Return(_a0 int64, _a1 error) *Collection_CountDocuments_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Collection_CountDocuments_Call) RunAndReturn(run func(interface{}, ...interface{}) (int64, error)) *Collection_CountDocuments_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: document
func (_m *Collection) Create(document interface{}) error {
	ret := _m.Called(document)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(document)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Collection_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Collection_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - document interface{}
func (_e *Collection_Expecter) Create(document interface{}) *Collection_Create_Call {
	return &Collection_Create_Call{Call: _e.mock.On("Create", document)}
}

func (_c *Collection_Create_Call) Run(run func(document interface{})) *Collection_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Collection_Create_Call) Return(_a0 error) *Collection_Create_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Collection_Create_Call) RunAndReturn(run func(interface{}) error) *Collection_Create_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMany provides a mock function with given fields: filter, opts
func (_m *Collection) DeleteMany(filter interface{}, opts ...interface{}) (*mongo.DeleteResult, error) {
	var _ca []interface{}
	_ca = append(_ca, filter)
	_ca = append(_ca, opts...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMany")
	}

	var r0 *mongo.DeleteResult
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) (*mongo.DeleteResult, error)); ok {
		return rf(filter, opts...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *mongo.DeleteResult); ok {
		r0 = rf(filter, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mongo.DeleteResult)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...interface{}) error); ok {
		r1 = rf(filter, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Collection_DeleteMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMany'
type Collection_DeleteMany_Call struct {
	*mock.Call
}

// DeleteMany is a helper method to define mock.On call
//   - filter interface{}
//   - opts ...interface{}
func (_e *Collection_Expecter) DeleteMany(filter interface{}, opts ...interface{}) *Collection_DeleteMany_Call {
	return &Collection_DeleteMany_Call{Call: _e.mock.On("DeleteMany",
		append([]interface{}{filter}, opts...)...)}
}

func (_c *Collection_DeleteMany_Call) Run(run func(filter interface{}, opts ...interface{})) *Collection_DeleteMany_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Collection_DeleteMany_Call) Return(_a0 *mongo.DeleteResult, _a1 error) *Collection_DeleteMany_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Collection_DeleteMany_Call) RunAndReturn(run func(interface{}, ...interface{}) (*mongo.DeleteResult, error)) *Collection_DeleteMany_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteOne provides a mock function with given fields: filter, opts
func (_m *Collection) DeleteOne(filter interface{}, opts ...interface{}) (*mongo.DeleteResult, error) {
	var _ca []interface{}
	_ca = append(_ca, filter)
	_ca = append(_ca, opts...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOne")
	}

	var r0 *mongo.DeleteResult
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) (*mongo.DeleteResult, error)); ok {
		return rf(filter, opts...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *mongo.DeleteResult); ok {
		r0 = rf(filter, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mongo.DeleteResult)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...interface{}) error); ok {
		r1 = rf(filter, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Collection_DeleteOne_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteOne'
type Collection_DeleteOne_Call struct {
	*mock.Call
}

// DeleteOne is a helper method to define mock.On call
//   - filter interface{}
//   - opts ...interface{}
func (_e *Collection_Expecter) DeleteOne(filter interface{}, opts ...interface{}) *Collection_DeleteOne_Call {
	return &Collection_DeleteOne_Call{Call: _e.mock.On("DeleteOne",
		append([]interface{}{filter}, opts...)...)}
}

func (_c *Collection_DeleteOne_Call) Run(run func(filter interface{}, opts ...interface{})) *Collection_DeleteOne_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Collection_DeleteOne_Call) Return(_a0 *mongo.DeleteResult, _a1 error) *Collection_DeleteOne_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Collection_DeleteOne_Call) RunAndReturn(run func(interface{}, ...interface{}) (*mongo.DeleteResult, error)) *Collection_DeleteOne_Call {
	_c.Call.Return(run)
	return _c
}

// Drop provides a mock function with no fields
func (_m *Collection) Drop() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Drop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Collection_Drop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Drop'
type Collection_Drop_Call struct {
	*mock.Call
}

// Drop is a helper method to define mock.On call
func (_e *Collection_Expecter) Drop() *Collection_Drop_Call {
	return &Collection_Drop_Call{Call: _e.mock.On("Drop")}
}

func (_c *Collection_Drop_Call) Run(run func()) *Collection_Drop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Collection_Drop_Call) Return(_a0 error) *Collection_Drop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Collection_Drop_Call) RunAndReturn(run func() error) *Collection_Drop_Call {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function with given fields: filter, opts
func (_m *Collection) Find(filter interface{}, opts ...interface{}) (*mongo.Cursor, error) {
	var _ca []interface{}
	_ca = append(_ca, filter)
	_ca = append(_ca, opts...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 *mongo.Cursor
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) (*mongo.Cursor, error)); ok {
		return rf(filter, opts...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *mongo.Cursor); ok {
		r0 = rf(filter, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mongo.Cursor)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...interface{}) error); ok {
		r1 = rf(filter, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Collection_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type Collection_Find_Call struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - filter interface{}
//   - opts ...interface{}
func (_e *Collection_Expecter) Find(filter interface{}, opts ...interface{}) *Collection_Find_Call {
	return &Collection_Find_Call{Call: _e.mock.On("Find",
		append([]interface{}{filter}, opts...)...)}
}

func (_c *Collection_Find_Call) Run(run func(filter interface{}, opts ...interface{})) *Collection_Find_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Collection_Find_Call) Return(_a0 *mongo.Cursor, _a1 error) *Collection_Find_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Collection_Find_Call) RunAndReturn(run func(interface{}, ...interface{}) (*mongo.Cursor, error)) *Collection_Find_Call {
	_c.Call.Return(run)
	return _c
}

// FindOne provides a mock function with given fields: filter, result, opts
func (_m *Collection) FindOne(filter interface{}, result interface{}, opts ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, filter, result)
	_ca = append(_ca, opts...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindOne")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...interface{}) error); ok {
		r0 = rf(filter, result, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Collection_FindOne_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOne'
type Collection_FindOne_Call struct {
	*mock.Call
}

// FindOne is a helper method to define mock.On call
//   - filter interface{}
//   - result interface{}
//   - opts ...interface{}
func (_e *Collection_Expecter) FindOne(filter interface{}, result interface{}, opts ...interface{}) *Collection_FindOne_Call {
	return &Collection_FindOne_Call{Call: _e.mock.On("FindOne",
		append([]interface{}{filter, result}, opts...)...)}
}

func (_c *Collection_FindOne_Call) Run(run func(filter interface{}, result interface{}, opts ...interface{})) *Collection_FindOne_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Collection_FindOne_Call) Return(_a0 error) *Collection_FindOne_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Collection_FindOne_Call) RunAndReturn(run func(interface{}, interface{}, ...interface{}) error) *Collection_FindOne_Call {
	_c.Call.Return(run)
	return _c
}

// First provides a mock function with given fields: result, filter
func (_m *Collection) First(result interface{}, filter ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, result)
	_ca = append(_ca, filter...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for First")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) error); ok {
		r0 = rf(result, filter...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Collection_First_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'First'
type Collection_First_Call struct {
	*mock.Call
}

// First is a helper method to define mock.On call
//   - result interface{}
//   - filter ...interface{}
func (_e *Collection_Expecter) First(result interface{}, filter ...interface{}) *Collection_First_Call {
	return &Collection_First_Call{Call: _e.mock.On("First",
		append([]interface{}{result}, filter...)...)}
}

func (_c *Collection_First_Call) Run(run func(result interface{}, filter ...interface{})) *Collection_First_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Collection_First_Call) Return(_a0 error) *Collection_First_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Collection_First_Call) RunAndReturn(run func(interface{}, ...interface{}) error) *Collection_First_Call {
	_c.Call.Return(run)
	return _c
}

// InsertMany provides a mock function with given fields: documents, opts
func (_m *Collection) InsertMany(documents []interface{}, opts ...interface{}) (*mongo.InsertManyResult, error) {
	var _ca []interface{}
	_ca = append(_ca, documents)
	_ca = append(_ca, opts...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InsertMany")
	}

	var r0 *mongo.InsertManyResult
	var r1 error
	if rf, ok := ret.Get(0).(func([]interface{}, ...interface{}) (*mongo.InsertManyResult, error)); ok {
		return rf(documents, opts...)
	}
	if rf, ok := ret.Get(0).(func([]interface{}, ...interface{}) *mongo.InsertManyResult); ok {
		r0 = rf(documents, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mongo.InsertManyResult)
		}
	}

	if rf, ok := ret.Get(1).(func([]interface{}, ...interface{}) error); ok {
		r1 = rf(documents, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Collection_InsertMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertMany'
type Collection_InsertMany_Call struct {
	*mock.Call
}

// InsertMany is a helper method to define mock.On call
//   - documents []interface{}
//   - opts ...interface{}
func (_e *Collection_Expecter) InsertMany(documents interface{}, opts ...interface{}) *Collection_InsertMany_Call {
	return &Collection_InsertMany_Call{Call: _e.mock.On("InsertMany",
		append([]interface{}{documents}, opts...)...)}
}

func (_c *Collection_InsertMany_Call) Run(run func(documents []interface{}, opts ...interface{})) *Collection_InsertMany_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].([]interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Collection_InsertMany_Call) Return(_a0 *mongo.InsertManyResult, _a1 error) *Collection_InsertMany_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Collection_InsertMany_Call) RunAndReturn(run func([]interface{}, ...interface{}) (*mongo.InsertManyResult, error)) *Collection_InsertMany_Call {
	_c.Call.Return(run)
	return _c
}

// InsertOne provides a mock function with given fields: document, opts
func (_m *Collection) InsertOne(document interface{}, opts ...interface{}) (*mongo.InsertOneResult, error) {
	var _ca []interface{}
	_ca = append(_ca, document)
	_ca = append(_ca, opts...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InsertOne")
	}

	var r0 *mongo.InsertOneResult
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) (*mongo.InsertOneResult, error)); ok {
		return rf(document, opts...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *mongo.InsertOneResult); ok {
		r0 = rf(document, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mongo.InsertOneResult)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...interface{}) error); ok {
		r1 = rf(document, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Collection_InsertOne_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertOne'
type Collection_InsertOne_Call struct {
	*mock.Call
}

// InsertOne is a helper method to define mock.On call
//   - document interface{}
//   - opts ...interface{}
func (_e *Collection_Expecter) InsertOne(document interface{}, opts ...interface{}) *Collection_InsertOne_Call {
	return &Collection_InsertOne_Call{Call: _e.mock.On("InsertOne",
		append([]interface{}{document}, opts...)...)}
}

func (_c *Collection_InsertOne_Call) Run(run func(document interface{}, opts ...interface{})) *Collection_InsertOne_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Collection_InsertOne_Call) Return(_a0 *mongo.InsertOneResult, _a1 error) *Collection_InsertOne_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Collection_InsertOne_Call) RunAndReturn(run func(interface{}, ...interface{}) (*mongo.InsertOneResult, error)) *Collection_InsertOne_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function with no fields
func (_m *Collection) Name() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Collection_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type Collection_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *Collection_Expecter) Name() *Collection_Name_Call {
	return &Collection_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *Collection_Name_Call) Run(run func()) *Collection_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Collection_Name_Call) Return(_a0 string) *Collection_Name_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Collection_Name_Call) RunAndReturn(run func() string) *Collection_Name_Call {
	_c.Call.Return(run)
	return _c
}

// Native provides a mock function with no fields
func (_m *Collection) Native() *mongo.Collection {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Native")
	}

	var r0 *mongo.Collection
	if rf, ok := ret.Get(0).(func() *mongo.Collection); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mongo.Collection)
		}
	}

	return r0
}

// Collection_Native_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Native'
type Collection_Native_Call struct {
	*mock.Call
}

// Native is a helper method to define mock.On call
func (_e *Collection_Expecter) Native() *Collection_Native_Call {
	return &Collection_Native_Call{Call: _e.mock.On("Native")}
}

func (_c *Collection_Native_Call) Run(run func()) *Collection_Native_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Collection_Native_Call) Return(_a0 *mongo.Collection) *Collection_Native_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Collection_Native_Call) RunAndReturn(run func() *mongo.Collection) *Collection_Native_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMany provides a mock function with given fields: filter, update, opts
func (_m *Collection) UpdateMany(filter interface{}, update interface{}, opts ...interface{}) (*mongo.UpdateResult, error) {
	var _ca []interface{}
	_ca = append(_ca, filter, update)
	_ca = append(_ca, opts...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMany")
	}

	var r0 *mongo.UpdateResult
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...interface{}) (*mongo.UpdateResult, error)); ok {
		return rf(filter, update, opts...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...interface{}) *mongo.UpdateResult); ok {
		r0 = rf(filter, update, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mongo.UpdateResult)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, ...interface{}) error); ok {
		r1 = rf(filter, update, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Collection_UpdateMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMany'
type Collection_UpdateMany_Call struct {
	*mock.Call
}

// UpdateMany is a helper method to define mock.On call
//   - filter interface{}
//   - update interface{}
//   - opts ...interface{}
func (_e *Collection_Expecter) UpdateMany(filter interface{}, update interface{}, opts ...interface{}) *Collection_UpdateMany_Call {
	return &Collection_UpdateMany_Call{Call: _e.mock.On("UpdateMany",
		append([]interface{}{filter, update}, opts...)...)}
}

func (_c *Collection_UpdateMany_Call) Run(run func(filter interface{}, update interface{}, opts ...interface{})) *Collection_UpdateMany_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Collection_UpdateMany_Call) Return(_a0 *mongo.UpdateResult, _a1 error) *Collection_UpdateMany_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Collection_UpdateMany_Call) RunAndReturn(run func(interface{}, interface{}, ...interface{}) (*mongo.UpdateResult, error)) *Collection_UpdateMany_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateOne provides a mock function with given fields: filter, update, opts
func (_m *Collection) UpdateOne(filter interface{}, update interface{}, opts ...interface{}) (*mongo.UpdateResult, error) {
	var _ca []interface{}
	_ca = append(_ca, filter, update)
	_ca = append(_ca, opts...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOne")
	}

	var r0 *mongo.UpdateResult
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...interface{}) (*mongo.UpdateResult, error)); ok {
		return rf(filter, update, opts...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...interface{}) *mongo.UpdateResult); ok {
		r0 = rf(filter, update, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mongo.UpdateResult)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, ...interface{}) error); ok {
		r1 = rf(filter, update, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Collection_UpdateOne_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateOne'
type Collection_UpdateOne_Call struct {
	*mock.Call
}

// UpdateOne is a helper method to define mock.On call
//   - filter interface{}
//   - update interface{}
//   - opts ...interface{}
func (_e *Collection_Expecter) UpdateOne(filter interface{}, update interface{}, opts ...interface{}) *Collection_UpdateOne_Call {
	return &Collection_UpdateOne_Call{Call: _e.mock.On("UpdateOne",
		append([]interface{}{filter, update}, opts...)...)}
}

func (_c *Collection_UpdateOne_Call) Run(run func(filter interface{}, update interface{}, opts ...interface{})) *Collection_UpdateOne_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Collection_UpdateOne_Call) Return(_a0 *mongo.UpdateResult, _a1 error) *Collection_UpdateOne_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Collection_UpdateOne_Call) RunAndReturn(run func(interface{}, interface{}, ...interface{}) (*mongo.UpdateResult, error)) *Collection_UpdateOne_Call {
	_c.Call.Return(run)
	return _c
}

// Where provides a mock function with given fields: field, value
func (_m *Collection) Where(field string, value interface{}) contracts.QueryBuilder {
	ret := _m.Called(field, value)

	if len(ret) == 0 {
		panic("no return value specified for Where")
	}

	var r0 contracts.QueryBuilder
	if rf, ok := ret.Get(0).(func(string, interface{}) contracts.QueryBuilder); ok {
		r0 = rf(field, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(contracts.QueryBuilder)
		}
	}

	return r0
}

// Collection_Where_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Where'
type Collection_Where_Call struct {
	*mock.Call
}

// Where is a helper method to define mock.On call
//   - field string
//   - value interface{}
func (_e *Collection_Expecter) Where(field interface{}, value interface{}) *Collection_Where_Call {
	return &Collection_Where_Call{Call: _e.mock.On("Where", field, value)}
}

func (_c *Collection_Where_Call) Run(run func(field string, value interface{})) *Collection_Where_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Collection_Where_Call) Return(_a0 contracts.QueryBuilder) *Collection_Where_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Collection_Where_Call) RunAndReturn(run func(string, interface{}) contracts.QueryBuilder) *Collection_Where_Call {
	_c.Call.Return(run)
	return _c
}

// NewCollection creates a new instance of Collection. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCollection(t interface {
	mock.TestingT
	Cleanup(func())
}) *Collection {
	mock := &Collection{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
